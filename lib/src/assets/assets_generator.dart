#!/usr/bin/env dart

import 'dart:io';

/// Flutter 资源文件生成器
///
/// 自动扫描指定目录下的所有资源文件，生成对应的 Dart 常量文件
/// 并可选择性地自动更新 pubspec.yaml 文件中的 assets 配置
class FlutterAssetsGenerator {
  // 默认配置项

  /// 资源文件所在的目录路径
  static String assetsDir = 'assets';

  /// 输出的 Dart 文件路径
  static String outputFile = 'lib/generated/assets.dart';

  /// 生成的类名
  static String className = 'Assets';

  /// pubspec.yaml 文件路径
  static String pubspecFile = 'pubspec.yaml';

  /// 命名方式配置
  ///
  /// true=简短命名(父级文件夹+文件名), false=完整路径命名
  static bool useShortNaming = true;

  /// 是否自动更新 pubspec.yaml 文件
  static bool autoUpdatePubspec = true;

  /// 需要忽略的文件夹列表
  static List<String> ignoredFolders = [];

  /// 开始生成资源文件索引
  ///
  /// 扫描指定目录，收集所有资源文件，生成包含常量定义的 Dart 文件
  /// 可选择性地自动更新 pubspec.yaml 中的 assets 配置
  static Future<void> generate() async {
    print('开始生成Flutter资源文件索引...');

    // 检查assets目录是否存在
    final assetsDirectory = Directory(assetsDir);
    if (!await assetsDirectory.exists()) {
      print('错误: $assetsDir 目录不存在');
      return;
    }

    // 收集所有资源文件和文件夹
    final assetFiles = <String>[];
    final assetFolders = <String>{};
    await _collectAssets(assetsDirectory, assetFiles, assetFolders);

    if (assetFiles.isEmpty) {
      print('警告: 未找到任何资源文件');
      return;
    }

    // 生成Dart代码
    final dartCode = _generateDartCode(assetFiles);

    // 确保输出目录存在
    final outputFileObj = File(outputFile);
    await outputFileObj.parent.create(recursive: true);

    // 写入文件
    await outputFileObj.writeAsString(dartCode);

    // 更新pubspec.yaml
    if (autoUpdatePubspec) {
      await _updatePubspecYaml(assetFolders);
    }

    print('✅ 资源文件索引生成完成！');
    print('📁 生成文件: $outputFile');
    print('📊 共处理 ${assetFiles.length} 个资源文件');
    if (autoUpdatePubspec) {
      print('📝 已更新 $pubspecFile 配置');
    }
  }

  /// 递归收集资源文件
  ///
  /// 遍历指定目录及其子目录，收集所有资源文件的路径
  /// 同时收集文件夹路径用于 pubspec.yaml 配置
  ///
  /// [dir] 要扫描的目录
  /// [assetFiles] 收集到的资源文件路径列表
  /// [assetFolders] 收集到的文件夹路径集合
  static Future<void> _collectAssets(
      Directory dir, List<String> assetFiles, Set<String> assetFolders) async {
    await for (final entity in dir.list()) {
      if (entity is Directory) {
        // 检查是否需要忽略此文件夹
        if (_shouldIgnoreFolder(entity.path)) {
          print('⏭️  忽略文件夹: ${entity.path}');
          continue;
        }

        // 递归处理子目录
        await _collectAssets(entity, assetFiles, assetFolders);
      } else if (entity is File) {
        // 添加到资源列表
        final relativePath = entity.path.replaceAll('\\', '/');
        assetFiles.add(relativePath);

        // 添加文件夹到集合（用于pubspec.yaml配置）
        final folderPath = entity.parent.path.replaceAll('\\', '/');
        if (!folderPath.endsWith(assetsDir)) {
          assetFolders.add('$folderPath/');
        }

        print('✓ 添加资源: $relativePath');
      }
    }
  }

  /// 检查是否应该忽略文件夹
  ///
  /// 根据配置的忽略列表判断指定路径是否应该被忽略
  ///
  /// [folderPath] 文件夹路径
  /// 返回 true 表示应该忽略，false 表示不忽略
  static bool _shouldIgnoreFolder(String folderPath) {
    // 标准化路径分隔符
    final normalizedPath = folderPath.replaceAll('\\', '/');

    // 分割路径为各个部分
    final pathParts = normalizedPath.split('/');

    // 检查路径中的每个部分是否在忽略列表中
    for (final part in pathParts) {
      if (part.isEmpty) continue;

      for (final ignored in ignoredFolders) {
        // 精确匹配文件夹名称
        if (part.toLowerCase() == ignored.toLowerCase()) {
          return true;
        }
      }
    }

    return false;
  }

  /// 生成 Dart 代码
  ///
  /// 根据收集到的资源文件列表生成包含常量定义的完整 Dart 文件内容
  /// 处理命名冲突并确保生成有效的常量名
  ///
  /// [assetFiles] 资源文件路径列表
  /// 返回生成的 Dart 代码字符串
  static String _generateDartCode(List<String> assetFiles) {
    final buffer = StringBuffer();

    // 文件头注释
    buffer.writeln('/// 自动生成的资源文件索引,请勿手动修改此文件');
    buffer.writeln('/// Generated by flutter_chen_assets_generator');

    // 类定义开始
    buffer.writeln('class $className {');
    buffer.writeln('  ${className}._();');
    buffer.writeln();

    // 对文件路径进行排序
    assetFiles.sort();

    // 按基础常量名分组
    final nameGroups = <String, List<String>>{};

    // 第一遍：按基础常量名分组
    for (final assetPath in assetFiles) {
      final baseName = _generateConstantName(assetPath);
      nameGroups.putIfAbsent(baseName, () => []).add(assetPath);
    }

    // 第二遍：生成最终的常量名
    final finalConstants = <String, String>{}; // 最终常量名 -> 文件路径

    for (final entry in nameGroups.entries) {
      final baseName = entry.key;
      final filePaths = entry.value;

      if (filePaths.length == 1) {
        // 无冲突，使用基础名
        finalConstants[baseName] = filePaths.first;
      } else {
        // 有冲突，第一个保持原名，其余添加扩展名后缀
        for (int i = 0; i < filePaths.length; i++) {
          final filePath = filePaths[i];

          if (i == 0) {
            // 第一个文件保持原名
            finalConstants[baseName] = filePath;
          } else {
            // 后续文件添加扩展名后缀
            final extension = _getFileExtension(filePath);
            final finalName = '${baseName}${_capitalizeFirst(extension)}';
            finalConstants[finalName] = filePath;
          }
        }
      }
    }

    // 按常量名排序并生成代码
    final sortedEntries = finalConstants.entries.toList()
      ..sort((a, b) => a.key.compareTo(b.key));

    for (final entry in sortedEntries) {
      buffer.writeln("  static const String ${entry.key} = '${entry.value}';");
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  /// 根据文件路径生成常量名称
  ///
  /// 支持两种命名方式：简短命名和完整路径命名
  /// 生成符合 Dart 变量命名规范的常量名
  ///
  /// [assetPath] 资源文件的完整路径
  /// 返回生成的常量名称
  static String _generateConstantName(String assetPath) {
    // 移除assets/前缀
    String path = assetPath;
    if (path.startsWith('$assetsDir/')) {
      path = path.substring('$assetsDir/'.length);
    }

    String name;

    if (useShortNaming) {
      // 简短命名：父级文件夹 + 文件名
      final pathParts = path.split('/');

      // 获取文件名（去除扩展名）
      String fileName = pathParts.last;
      final lastDotIndex = fileName.lastIndexOf('.');
      if (lastDotIndex != -1) {
        fileName = fileName.substring(0, lastDotIndex);
      }

      // 获取父级文件夹名（如果存在）
      String? parentFolder;
      if (pathParts.length > 1) {
        parentFolder = pathParts[pathParts.length - 2]; // 倒数第二个就是父级文件夹
      }

      // 构建常量名：父级文件夹名 + 文件名
      if (parentFolder != null && parentFolder.isNotEmpty) {
        name = '${parentFolder}_$fileName';
      } else {
        name = fileName;
      }
    } else {
      // 完整路径命名：所有文件夹 + 文件名
      name = path;

      // 移除文件扩展名
      final lastDotIndex = name.lastIndexOf('.');
      if (lastDotIndex != -1) {
        name = name.substring(0, lastDotIndex);
      }

      // 将路径分隔符替换为下划线
      name = name.replaceAll('/', '_');
    }

    // 清理特殊字符
    name = name
        .replaceAll('-', '_')
        .replaceAll(' ', '_')
        .replaceAll(RegExp(r'[^\w]'), '_');

    // 转换为驼峰命名
    final parts = name.split('_');
    final camelCase = StringBuffer();

    for (int i = 0; i < parts.length; i++) {
      final part = parts[i];
      if (part.isEmpty) continue;

      if (i == 0) {
        // 第一个部分保持原有的大小写格式（如果已经是驼峰的话）
        camelCase.write(_toCamelCaseWord(part, false));
      } else {
        // 后续部分首字母大写
        camelCase.write(_toCamelCaseWord(part, true));
      }
    }

    String result = camelCase.toString();

    // 确保不以数字开头
    if (result.isNotEmpty && RegExp(r'^\d').hasMatch(result)) {
      result = 'asset$result';
    }

    // 确保不为空
    if (result.isEmpty) {
      result = 'unknown';
    }

    return result;
  }

  /// 智能处理驼峰命名的单词
  ///
  /// 识别并保持已有的驼峰格式，或根据需要转换为驼峰格式
  ///
  /// [word] 要处理的单词
  /// [capitalize] 是否将首字母大写
  /// 返回处理后的单词
  static String _toCamelCaseWord(String word, bool capitalize) {
    if (word.isEmpty) return word;

    // 检查是否已经是驼峰格式（包含大写字母且不是全大写）
    final hasLowerCase = word.contains(RegExp(r'[a-z]'));
    final hasUpperCase = word.contains(RegExp(r'[A-Z]'));
    final isAllUpperCase = word == word.toUpperCase();

    if (hasLowerCase && hasUpperCase && !isAllUpperCase) {
      // 已经是驼峰格式，保持原样或调整首字母
      if (capitalize) {
        return word[0].toUpperCase() + word.substring(1);
      } else {
        return word[0].toLowerCase() + word.substring(1);
      }
    } else {
      // 普通单词，按标准规则处理
      if (capitalize) {
        return word[0].toUpperCase() + word.substring(1).toLowerCase();
      } else {
        return word.toLowerCase();
      }
    }
  }

  /// 获取文件扩展名（不含点号）
  ///
  /// [filePath] 文件路径
  /// 返回小写的文件扩展名，如果没有扩展名则返回空字符串
  static String _getFileExtension(String filePath) {
    final lastDotIndex = filePath.lastIndexOf('.');
    if (lastDotIndex != -1 && lastDotIndex < filePath.length - 1) {
      return filePath.substring(lastDotIndex + 1).toLowerCase();
    }
    return '';
  }

  /// 首字母大写
  ///
  /// [text] 要处理的文本
  /// 返回首字母大写的文本
  static String _capitalizeFirst(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  /// 更新 pubspec.yaml 文件的 assets 配置
  ///
  /// 自动在 pubspec.yaml 中添加或更新 assets 配置
  /// 合并现有配置和新发现的资源文件夹
  ///
  /// [assetFolders] 需要添加到配置中的资源文件夹集合
  static Future<void> _updatePubspecYaml(Set<String> assetFolders) async {
    final pubspecFileObj = File(pubspecFile);

    if (!await pubspecFileObj.exists()) {
      print('⚠️  警告: $pubspecFile 文件不存在，跳过更新');
      return;
    }

    try {
      // 读取pubspec.yaml内容
      final content = await pubspecFileObj.readAsString();
      final lines = content.split('\n');

      // 查找flutter和assets部分
      int flutterIndex = -1;
      int assetsIndex = -1;
      int assetsEndIndex = -1;
      final existingAssets = <String>{};

      for (int i = 0; i < lines.length; i++) {
        final line = lines[i];
        final trimmedLine = line.trim();

        if (trimmedLine.startsWith('flutter:')) {
          flutterIndex = i;
        } else if (flutterIndex != -1 && trimmedLine.startsWith('assets:')) {
          assetsIndex = i;
        } else if (assetsIndex != -1) {
          // 检查是否是assets项
          if (line.startsWith('    - ') || line.startsWith('\t\t- ')) {
            final assetPath = trimmedLine.substring(2).trim(); // 移除 "- "
            existingAssets.add(assetPath);
          } else if (trimmedLine.isNotEmpty &&
              !trimmedLine.startsWith(' ') &&
              !trimmedLine.startsWith('\t')) {
            // 遇到下一个配置项，assets部分结束
            assetsEndIndex = i;
            break;
          }
        }
      }

      // 如果没有找到assets结束位置，设为文件末尾
      if (assetsIndex != -1 && assetsEndIndex == -1) {
        assetsEndIndex = lines.length;
      }

      // 准备新的assets配置（合并现有的和新发现的）
      final allAssets = <String>{};

      // 添加现有的assets
      allAssets.addAll(existingAssets);

      // 添加assets根目录
      allAssets.add('$assetsDir/');

      // 添加所有发现的子文件夹
      allAssets.addAll(assetFolders);

      // 检查是否有变化
      final sortedAssets = allAssets.toList()..sort();
      final sortedExisting = existingAssets.toList()..sort();

      if (sortedAssets.join(',') == sortedExisting.join(',')) {
        print('📝 pubspec.yaml 的 assets 配置已是最新，无需更新');
        return;
      }

      // 构建新的assets配置行
      final newAssetsLines = <String>[];
      newAssetsLines.add('  assets:');

      for (final asset in sortedAssets) {
        newAssetsLines.add('    - $asset');
      }

      // 重建文件内容
      final newLines = <String>[];

      if (assetsIndex == -1) {
        // 如果没有assets配置，在flutter部分添加
        if (flutterIndex == -1) {
          // 如果连flutter部分都没有，在文件末尾添加
          newLines.addAll(lines);
          newLines.add('');
          newLines.add('flutter:');
          newLines.addAll(newAssetsLines);
        } else {
          // 在flutter部分后添加assets配置
          newLines.addAll(lines.sublist(0, flutterIndex + 1));
          newLines.addAll(newAssetsLines);
          newLines.addAll(lines.sublist(flutterIndex + 1));
        }
      } else {
        // 替换现有的assets配置
        newLines.addAll(lines.sublist(0, assetsIndex));
        newLines.addAll(newAssetsLines);
        newLines.addAll(lines.sublist(assetsEndIndex));
      }

      // 写回文件
      await pubspecFileObj.writeAsString(newLines.join('\n'));

      final addedCount = allAssets.length - existingAssets.length;
      if (addedCount > 0) {
        print('✅ 已更新 $pubspecFile 中的 assets 配置（新增 $addedCount 项）');
      } else {
        print('✅ 已更新 $pubspecFile 中的 assets 配置');
      }
    } catch (e) {
      print('⚠️  更新 $pubspecFile 时出错: $e');
    }
  }
}

/// 解析命令行参数
///
/// 处理用户提供的命令行选项，设置相应的配置参数
///
/// [arguments] 命令行参数列表
/// 返回 true 表示应该退出程序（如显示帮助信息），false 表示继续执行
bool _parseArguments(List<String> arguments) {
  for (int i = 0; i < arguments.length; i++) {
    final arg = arguments[i];

    switch (arg) {
      case '--help':
      case '-h':
        _printHelp();
        return true;

      case '--assets-dir':
      case '-a':
        if (i + 1 < arguments.length) {
          FlutterAssetsGenerator.assetsDir = arguments[++i];
        } else {
          print('❌ --assets-dir 需要指定目录路径');
          return true;
        }
        break;

      case '--output':
      case '-o':
        if (i + 1 < arguments.length) {
          FlutterAssetsGenerator.outputFile = arguments[++i];
        } else {
          print('❌ --output 需要指定输出文件路径');
          return true;
        }
        break;

      case '--class-name':
      case '-c':
        if (i + 1 < arguments.length) {
          FlutterAssetsGenerator.className = arguments[++i];
        } else {
          print('❌ --class-name 需要指定类名');
          return true;
        }
        break;

      case '--short-naming':
        FlutterAssetsGenerator.useShortNaming = true;
        break;

      case '--full-naming':
        FlutterAssetsGenerator.useShortNaming = false;
        break;

      case '--update-pubspec':
        FlutterAssetsGenerator.autoUpdatePubspec = true;
        break;

      case '--no-update-pubspec':
        FlutterAssetsGenerator.autoUpdatePubspec = false;
        break;

      case '--ignore':
      case '-i':
        if (i + 1 < arguments.length) {
          final folders = arguments[++i].split(',');
          FlutterAssetsGenerator.ignoredFolders.addAll(folders);
        } else {
          print('❌ --ignore 需要指定要忽略的文件夹（用逗号分隔）');
          return true;
        }
        break;

      case '--clear-ignore':
        FlutterAssetsGenerator.ignoredFolders.clear();
        break;

      case '--version':
      case '-v':
        print('Flutter Chen Assets Generator');
        return true;

      default:
        if (arg.startsWith('-')) {
          print('❌ 未知参数: $arg');
          print('使用 --help 查看可用参数');
          return true;
        }
    }
  }

  return false;
}

/// 打印帮助信息
///
/// 在控制台输出详细的使用说明和参数说明
void _printHelp() {
  print('''
Flutter Chen Assets Generator - 自动生成Flutter资源文件索引

用法: flutter_chen_assets_generator [选项]

选项:
  -h, --help                    显示此帮助信息
  -v, --version                 显示版本信息
  
  -a, --assets-dir <dir>        指定资源目录 (默认: assets)
  -o, --output <file>           指定输出文件 (默认: lib/generated/assets.dart)
  -c, --class-name <name>       指定生成的类名 (默认: Assets)
  
  --short-naming               使用简短命名 (父级文件夹+文件名) [默认]
  --full-naming                使用完整路径命名
  
  --update-pubspec             自动更新 pubspec.yaml [默认]
  --no-update-pubspec          不更新 pubspec.yaml
  
  -i, --ignore <folders>       忽略指定文件夹 (用逗号分隔)
  --clear-ignore               清空默认忽略列表

示例:
  # 使用默认配置
  flutter_chen_assets_generator
  
  # 指定资源目录和输出文件
  flutter_chen_assets_generator -a my_assets -o lib/assets.dart
  
  # 使用完整命名并忽略特定文件夹
  flutter_chen_assets_generator --full-naming -i web,fonts,temp
  
  # 生成指定类名且不更新pubspec.yaml
  flutter_chen_assets_generator -c MyAssets --no-update-pubspec

默认忽略的文件夹: ${FlutterAssetsGenerator.ignoredFolders.join(', ')}

更多信息: https://pub.dev/packages/flutter_chen_assets_generator
''');
}

/// 主函数 - 程序入口点
///
/// 解析命令行参数并执行资源文件生成任务
///
/// [arguments] 命令行参数列表
Future<void> main(List<String> arguments) async {
  print('🚀 Flutter Chen Assets Generator');
  print('═' * 50);

  // 解析命令行参数
  if (_parseArguments(arguments)) {
    return;
  }

  try {
    await FlutterAssetsGenerator.generate();
    print('═' * 50);
    print('🎉 任务完成！');
  } catch (e, stackTrace) {
    print('❌ 生成失败: $e');
    print('堆栈跟踪: $stackTrace');
    exit(1);
  }
}
