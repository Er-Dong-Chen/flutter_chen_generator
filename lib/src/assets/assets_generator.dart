#!/usr/bin/env dart

import 'dart:io';

class FlutterAssetsGenerator {
  // é»˜è®¤é…ç½®é¡¹
  static String assetsDir = 'assets';
  static String outputFile = 'lib/generated/assets.dart';
  static String className = 'Assets';
  static String pubspecFile = 'pubspec.yaml';

  // å‘½åæ–¹å¼é…ç½®ï¼štrue=ç®€çŸ­å‘½å(çˆ¶çº§æ–‡ä»¶å¤¹+æ–‡ä»¶å), false=å®Œæ•´è·¯å¾„å‘½å
  static bool useShortNaming = true;

  // æ˜¯å¦è‡ªåŠ¨æ›´æ–°pubspec.yaml
  static bool autoUpdatePubspec = true;

  // éœ€è¦å¿½ç•¥çš„æ–‡ä»¶å¤¹åˆ—è¡¨
  static List<String> ignoredFolders = [];

  static Future<void> generate() async {
    print('å¼€å§‹ç”ŸæˆFlutterèµ„æºæ–‡ä»¶ç´¢å¼•...');

    // æ£€æŸ¥assetsç›®å½•æ˜¯å¦å­˜åœ¨
    final assetsDirectory = Directory(assetsDir);
    if (!await assetsDirectory.exists()) {
      print('é”™è¯¯: $assetsDir ç›®å½•ä¸å­˜åœ¨');
      return;
    }

    // æ”¶é›†æ‰€æœ‰èµ„æºæ–‡ä»¶å’Œæ–‡ä»¶å¤¹
    final assetFiles = <String>[];
    final assetFolders = <String>{};
    await _collectAssets(assetsDirectory, assetFiles, assetFolders);

    if (assetFiles.isEmpty) {
      print('è­¦å‘Š: æœªæ‰¾åˆ°ä»»ä½•èµ„æºæ–‡ä»¶');
      return;
    }

    // ç”ŸæˆDartä»£ç 
    final dartCode = _generateDartCode(assetFiles);

    // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
    final outputFileObj = File(outputFile);
    await outputFileObj.parent.create(recursive: true);

    // å†™å…¥æ–‡ä»¶
    await outputFileObj.writeAsString(dartCode);

    // æ›´æ–°pubspec.yaml
    if (autoUpdatePubspec) {
      await _updatePubspecYaml(assetFolders);
    }

    print('âœ… èµ„æºæ–‡ä»¶ç´¢å¼•ç”Ÿæˆå®Œæˆï¼');
    print('ğŸ“ ç”Ÿæˆæ–‡ä»¶: $outputFile');
    print('ğŸ“Š å…±å¤„ç† ${assetFiles.length} ä¸ªèµ„æºæ–‡ä»¶');
    if (autoUpdatePubspec) {
      print('ğŸ“ å·²æ›´æ–° $pubspecFile é…ç½®');
    }
  }

  /// é€’å½’æ”¶é›†èµ„æºæ–‡ä»¶
  static Future<void> _collectAssets(
      Directory dir, List<String> assetFiles, Set<String> assetFolders) async {
    await for (final entity in dir.list()) {
      if (entity is Directory) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦å¿½ç•¥æ­¤æ–‡ä»¶å¤¹
        if (_shouldIgnoreFolder(entity.path)) {
          print('â­ï¸  å¿½ç•¥æ–‡ä»¶å¤¹: ${entity.path}');
          continue;
        }

        // é€’å½’å¤„ç†å­ç›®å½•
        await _collectAssets(entity, assetFiles, assetFolders);
      } else if (entity is File) {
        // æ·»åŠ åˆ°èµ„æºåˆ—è¡¨
        final relativePath = entity.path.replaceAll('\\', '/');
        assetFiles.add(relativePath);

        // æ·»åŠ æ–‡ä»¶å¤¹åˆ°é›†åˆï¼ˆç”¨äºpubspec.yamlé…ç½®ï¼‰
        final folderPath = entity.parent.path.replaceAll('\\', '/');
        if (!folderPath.endsWith(assetsDir)) {
          assetFolders.add('$folderPath/');
        }

        print('âœ“ æ·»åŠ èµ„æº: $relativePath');
      }
    }
  }

  /// æ£€æŸ¥æ˜¯å¦åº”è¯¥å¿½ç•¥æ–‡ä»¶å¤¹
  static bool _shouldIgnoreFolder(String folderPath) {
    // æ ‡å‡†åŒ–è·¯å¾„åˆ†éš”ç¬¦
    final normalizedPath = folderPath.replaceAll('\\', '/');

    // åˆ†å‰²è·¯å¾„ä¸ºå„ä¸ªéƒ¨åˆ†
    final pathParts = normalizedPath.split('/');

    // æ£€æŸ¥è·¯å¾„ä¸­çš„æ¯ä¸ªéƒ¨åˆ†æ˜¯å¦åœ¨å¿½ç•¥åˆ—è¡¨ä¸­
    for (final part in pathParts) {
      if (part.isEmpty) continue;

      for (final ignored in ignoredFolders) {
        // ç²¾ç¡®åŒ¹é…æ–‡ä»¶å¤¹åç§°
        if (part.toLowerCase() == ignored.toLowerCase()) {
          return true;
        }
      }
    }

    return false;
  }

  /// ç”ŸæˆDartä»£ç 
  static String _generateDartCode(List<String> assetFiles) {
    final buffer = StringBuffer();

    // æ–‡ä»¶å¤´æ³¨é‡Š
    buffer.writeln('/// è‡ªåŠ¨ç”Ÿæˆçš„èµ„æºæ–‡ä»¶ç´¢å¼•,è¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹æ­¤æ–‡ä»¶');
    buffer.writeln('/// Generated by flutter_chen_assets_generator');

    // ç±»å®šä¹‰å¼€å§‹
    buffer.writeln('class $className {');
    buffer.writeln('  ${className}._();');
    buffer.writeln();

    // å¯¹æ–‡ä»¶è·¯å¾„è¿›è¡Œæ’åº
    assetFiles.sort();

    // æŒ‰åŸºç¡€å¸¸é‡ååˆ†ç»„
    final nameGroups = <String, List<String>>{};

    // ç¬¬ä¸€éï¼šæŒ‰åŸºç¡€å¸¸é‡ååˆ†ç»„
    for (final assetPath in assetFiles) {
      final baseName = _generateConstantName(assetPath);
      nameGroups.putIfAbsent(baseName, () => []).add(assetPath);
    }

    // ç¬¬äºŒéï¼šç”Ÿæˆæœ€ç»ˆçš„å¸¸é‡å
    final finalConstants = <String, String>{}; // æœ€ç»ˆå¸¸é‡å -> æ–‡ä»¶è·¯å¾„

    for (final entry in nameGroups.entries) {
      final baseName = entry.key;
      final filePaths = entry.value;

      if (filePaths.length == 1) {
        // æ— å†²çªï¼Œä½¿ç”¨åŸºç¡€å
        finalConstants[baseName] = filePaths.first;
      } else {
        // æœ‰å†²çªï¼Œç¬¬ä¸€ä¸ªä¿æŒåŸåï¼Œå…¶ä½™æ·»åŠ æ‰©å±•ååç¼€
        for (int i = 0; i < filePaths.length; i++) {
          final filePath = filePaths[i];

          if (i == 0) {
            // ç¬¬ä¸€ä¸ªæ–‡ä»¶ä¿æŒåŸå
            finalConstants[baseName] = filePath;
          } else {
            // åç»­æ–‡ä»¶æ·»åŠ æ‰©å±•ååç¼€
            final extension = _getFileExtension(filePath);
            final finalName = '${baseName}${_capitalizeFirst(extension)}';
            finalConstants[finalName] = filePath;
          }
        }
      }
    }

    // æŒ‰å¸¸é‡åæ’åºå¹¶ç”Ÿæˆä»£ç 
    final sortedEntries = finalConstants.entries.toList()
      ..sort((a, b) => a.key.compareTo(b.key));

    for (final entry in sortedEntries) {
      buffer.writeln("  static const String ${entry.key} = '${entry.value}';");
    }

    buffer.writeln('}');

    return buffer.toString();
  }

  /// æ ¹æ®æ–‡ä»¶è·¯å¾„ç”Ÿæˆå¸¸é‡åç§°
  static String _generateConstantName(String assetPath) {
    // ç§»é™¤assets/å‰ç¼€
    String path = assetPath;
    if (path.startsWith('$assetsDir/')) {
      path = path.substring('$assetsDir/'.length);
    }

    String name;

    if (useShortNaming) {
      // ç®€çŸ­å‘½åï¼šçˆ¶çº§æ–‡ä»¶å¤¹ + æ–‡ä»¶å
      final pathParts = path.split('/');

      // è·å–æ–‡ä»¶åï¼ˆå»é™¤æ‰©å±•åï¼‰
      String fileName = pathParts.last;
      final lastDotIndex = fileName.lastIndexOf('.');
      if (lastDotIndex != -1) {
        fileName = fileName.substring(0, lastDotIndex);
      }

      // è·å–çˆ¶çº§æ–‡ä»¶å¤¹åï¼ˆå¦‚æœå­˜åœ¨ï¼‰
      String? parentFolder;
      if (pathParts.length > 1) {
        parentFolder = pathParts[pathParts.length - 2]; // å€’æ•°ç¬¬äºŒä¸ªå°±æ˜¯çˆ¶çº§æ–‡ä»¶å¤¹
      }

      // æ„å»ºå¸¸é‡åï¼šçˆ¶çº§æ–‡ä»¶å¤¹å + æ–‡ä»¶å
      if (parentFolder != null && parentFolder.isNotEmpty) {
        name = '${parentFolder}_$fileName';
      } else {
        name = fileName;
      }
    } else {
      // å®Œæ•´è·¯å¾„å‘½åï¼šæ‰€æœ‰æ–‡ä»¶å¤¹ + æ–‡ä»¶å
      name = path;

      // ç§»é™¤æ–‡ä»¶æ‰©å±•å
      final lastDotIndex = name.lastIndexOf('.');
      if (lastDotIndex != -1) {
        name = name.substring(0, lastDotIndex);
      }

      // å°†è·¯å¾„åˆ†éš”ç¬¦æ›¿æ¢ä¸ºä¸‹åˆ’çº¿
      name = name.replaceAll('/', '_');
    }

    // æ¸…ç†ç‰¹æ®Šå­—ç¬¦
    name = name
        .replaceAll('-', '_')
        .replaceAll(' ', '_')
        .replaceAll(RegExp(r'[^\w]'), '_');

    // è½¬æ¢ä¸ºé©¼å³°å‘½å
    final parts = name.split('_');
    final camelCase = StringBuffer();

    for (int i = 0; i < parts.length; i++) {
      final part = parts[i];
      if (part.isEmpty) continue;

      if (i == 0) {
        // ç¬¬ä¸€ä¸ªéƒ¨åˆ†ä¿æŒåŸæœ‰çš„å¤§å°å†™æ ¼å¼ï¼ˆå¦‚æœå·²ç»æ˜¯é©¼å³°çš„è¯ï¼‰
        camelCase.write(_toCamelCaseWord(part, false));
      } else {
        // åç»­éƒ¨åˆ†é¦–å­—æ¯å¤§å†™
        camelCase.write(_toCamelCaseWord(part, true));
      }
    }

    String result = camelCase.toString();

    // ç¡®ä¿ä¸ä»¥æ•°å­—å¼€å¤´
    if (result.isNotEmpty && RegExp(r'^\d').hasMatch(result)) {
      result = 'asset$result';
    }

    // ç¡®ä¿ä¸ä¸ºç©º
    if (result.isEmpty) {
      result = 'unknown';
    }

    return result;
  }

  /// æ™ºèƒ½å¤„ç†é©¼å³°å‘½åçš„å•è¯
  static String _toCamelCaseWord(String word, bool capitalize) {
    if (word.isEmpty) return word;

    // æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯é©¼å³°æ ¼å¼ï¼ˆåŒ…å«å¤§å†™å­—æ¯ä¸”ä¸æ˜¯å…¨å¤§å†™ï¼‰
    final hasLowerCase = word.contains(RegExp(r'[a-z]'));
    final hasUpperCase = word.contains(RegExp(r'[A-Z]'));
    final isAllUpperCase = word == word.toUpperCase();

    if (hasLowerCase && hasUpperCase && !isAllUpperCase) {
      // å·²ç»æ˜¯é©¼å³°æ ¼å¼ï¼Œä¿æŒåŸæ ·æˆ–è°ƒæ•´é¦–å­—æ¯
      if (capitalize) {
        return word[0].toUpperCase() + word.substring(1);
      } else {
        return word[0].toLowerCase() + word.substring(1);
      }
    } else {
      // æ™®é€šå•è¯ï¼ŒæŒ‰æ ‡å‡†è§„åˆ™å¤„ç†
      if (capitalize) {
        return word[0].toUpperCase() + word.substring(1).toLowerCase();
      } else {
        return word.toLowerCase();
      }
    }
  }

  /// è·å–æ–‡ä»¶æ‰©å±•åï¼ˆä¸å«ç‚¹å·ï¼‰
  static String _getFileExtension(String filePath) {
    final lastDotIndex = filePath.lastIndexOf('.');
    if (lastDotIndex != -1 && lastDotIndex < filePath.length - 1) {
      return filePath.substring(lastDotIndex + 1).toLowerCase();
    }
    return '';
  }

  /// é¦–å­—æ¯å¤§å†™
  static String _capitalizeFirst(String text) {
    if (text.isEmpty) return text;
    return text[0].toUpperCase() + text.substring(1);
  }

  /// æ›´æ–°pubspec.yamlæ–‡ä»¶çš„assetsé…ç½®
  static Future<void> _updatePubspecYaml(Set<String> assetFolders) async {
    final pubspecFileObj = File(pubspecFile);

    if (!await pubspecFileObj.exists()) {
      print('âš ï¸  è­¦å‘Š: $pubspecFile æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡æ›´æ–°');
      return;
    }

    try {
      // è¯»å–pubspec.yamlå†…å®¹
      final content = await pubspecFileObj.readAsString();
      final lines = content.split('\n');

      // æŸ¥æ‰¾flutterå’Œassetséƒ¨åˆ†
      int flutterIndex = -1;
      int assetsIndex = -1;
      int assetsEndIndex = -1;
      final existingAssets = <String>{};

      for (int i = 0; i < lines.length; i++) {
        final line = lines[i];
        final trimmedLine = line.trim();

        if (trimmedLine.startsWith('flutter:')) {
          flutterIndex = i;
        } else if (flutterIndex != -1 && trimmedLine.startsWith('assets:')) {
          assetsIndex = i;
        } else if (assetsIndex != -1) {
          // æ£€æŸ¥æ˜¯å¦æ˜¯assetsé¡¹
          if (line.startsWith('    - ') || line.startsWith('\t\t- ')) {
            final assetPath = trimmedLine.substring(2).trim(); // ç§»é™¤ "- "
            existingAssets.add(assetPath);
          } else if (trimmedLine.isNotEmpty &&
              !trimmedLine.startsWith(' ') &&
              !trimmedLine.startsWith('\t')) {
            // é‡åˆ°ä¸‹ä¸€ä¸ªé…ç½®é¡¹ï¼Œassetséƒ¨åˆ†ç»“æŸ
            assetsEndIndex = i;
            break;
          }
        }
      }

      // å¦‚æœæ²¡æœ‰æ‰¾åˆ°assetsç»“æŸä½ç½®ï¼Œè®¾ä¸ºæ–‡ä»¶æœ«å°¾
      if (assetsIndex != -1 && assetsEndIndex == -1) {
        assetsEndIndex = lines.length;
      }

      // å‡†å¤‡æ–°çš„assetsé…ç½®ï¼ˆåˆå¹¶ç°æœ‰çš„å’Œæ–°å‘ç°çš„ï¼‰
      final allAssets = <String>{};

      // æ·»åŠ ç°æœ‰çš„assets
      allAssets.addAll(existingAssets);

      // æ·»åŠ assetsæ ¹ç›®å½•
      allAssets.add('$assetsDir/');

      // æ·»åŠ æ‰€æœ‰å‘ç°çš„å­æ–‡ä»¶å¤¹
      allAssets.addAll(assetFolders);

      // æ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–
      final sortedAssets = allAssets.toList()..sort();
      final sortedExisting = existingAssets.toList()..sort();

      if (sortedAssets.join(',') == sortedExisting.join(',')) {
        print('ğŸ“ pubspec.yaml çš„ assets é…ç½®å·²æ˜¯æœ€æ–°ï¼Œæ— éœ€æ›´æ–°');
        return;
      }

      // æ„å»ºæ–°çš„assetsé…ç½®è¡Œ
      final newAssetsLines = <String>[];
      newAssetsLines.add('  assets:');

      for (final asset in sortedAssets) {
        newAssetsLines.add('    - $asset');
      }

      // é‡å»ºæ–‡ä»¶å†…å®¹
      final newLines = <String>[];

      if (assetsIndex == -1) {
        // å¦‚æœæ²¡æœ‰assetsé…ç½®ï¼Œåœ¨flutteréƒ¨åˆ†æ·»åŠ 
        if (flutterIndex == -1) {
          // å¦‚æœè¿flutteréƒ¨åˆ†éƒ½æ²¡æœ‰ï¼Œåœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ 
          newLines.addAll(lines);
          newLines.add('');
          newLines.add('flutter:');
          newLines.addAll(newAssetsLines);
        } else {
          // åœ¨flutteréƒ¨åˆ†åæ·»åŠ assetsé…ç½®
          newLines.addAll(lines.sublist(0, flutterIndex + 1));
          newLines.addAll(newAssetsLines);
          newLines.addAll(lines.sublist(flutterIndex + 1));
        }
      } else {
        // æ›¿æ¢ç°æœ‰çš„assetsé…ç½®
        newLines.addAll(lines.sublist(0, assetsIndex));
        newLines.addAll(newAssetsLines);
        newLines.addAll(lines.sublist(assetsEndIndex));
      }

      // å†™å›æ–‡ä»¶
      await pubspecFileObj.writeAsString(newLines.join('\n'));

      final addedCount = allAssets.length - existingAssets.length;
      if (addedCount > 0) {
        print('âœ… å·²æ›´æ–° $pubspecFile ä¸­çš„ assets é…ç½®ï¼ˆæ–°å¢ $addedCount é¡¹ï¼‰');
      } else {
        print('âœ… å·²æ›´æ–° $pubspecFile ä¸­çš„ assets é…ç½®');
      }
    } catch (e) {
      print('âš ï¸  æ›´æ–° $pubspecFile æ—¶å‡ºé”™: $e');
    }
  }
}

/// è§£æå‘½ä»¤è¡Œå‚æ•°
bool _parseArguments(List<String> arguments) {
  for (int i = 0; i < arguments.length; i++) {
    final arg = arguments[i];

    switch (arg) {
      case '--help':
      case '-h':
        _printHelp();
        return true;

      case '--assets-dir':
      case '-a':
        if (i + 1 < arguments.length) {
          FlutterAssetsGenerator.assetsDir = arguments[++i];
        } else {
          print('âŒ --assets-dir éœ€è¦æŒ‡å®šç›®å½•è·¯å¾„');
          return true;
        }
        break;

      case '--output':
      case '-o':
        if (i + 1 < arguments.length) {
          FlutterAssetsGenerator.outputFile = arguments[++i];
        } else {
          print('âŒ --output éœ€è¦æŒ‡å®šè¾“å‡ºæ–‡ä»¶è·¯å¾„');
          return true;
        }
        break;

      case '--class-name':
      case '-c':
        if (i + 1 < arguments.length) {
          FlutterAssetsGenerator.className = arguments[++i];
        } else {
          print('âŒ --class-name éœ€è¦æŒ‡å®šç±»å');
          return true;
        }
        break;

      case '--short-naming':
        FlutterAssetsGenerator.useShortNaming = true;
        break;

      case '--full-naming':
        FlutterAssetsGenerator.useShortNaming = false;
        break;

      case '--update-pubspec':
        FlutterAssetsGenerator.autoUpdatePubspec = true;
        break;

      case '--no-update-pubspec':
        FlutterAssetsGenerator.autoUpdatePubspec = false;
        break;

      case '--ignore':
      case '-i':
        if (i + 1 < arguments.length) {
          final folders = arguments[++i].split(',');
          FlutterAssetsGenerator.ignoredFolders.addAll(folders);
        } else {
          print('âŒ --ignore éœ€è¦æŒ‡å®šè¦å¿½ç•¥çš„æ–‡ä»¶å¤¹ï¼ˆç”¨é€—å·åˆ†éš”ï¼‰');
          return true;
        }
        break;

      case '--clear-ignore':
        FlutterAssetsGenerator.ignoredFolders.clear();
        break;

      case '--version':
      case '-v':
        print('Flutter Chen Assets Generator');
        return true;

      default:
        if (arg.startsWith('-')) {
          print('âŒ æœªçŸ¥å‚æ•°: $arg');
          print('ä½¿ç”¨ --help æŸ¥çœ‹å¯ç”¨å‚æ•°');
          return true;
        }
    }
  }

  return false;
}

/// æ‰“å°å¸®åŠ©ä¿¡æ¯
void _printHelp() {
  print('''
Flutter Chen Assets Generator - è‡ªåŠ¨ç”ŸæˆFlutterèµ„æºæ–‡ä»¶ç´¢å¼•

ç”¨æ³•: flutter_chen_assets_generator [é€‰é¡¹]

é€‰é¡¹:
  -h, --help                    æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯
  -v, --version                 æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯
  
  -a, --assets-dir <dir>        æŒ‡å®šèµ„æºç›®å½• (é»˜è®¤: assets)
  -o, --output <file>           æŒ‡å®šè¾“å‡ºæ–‡ä»¶ (é»˜è®¤: lib/generated/assets.dart)
  -c, --class-name <name>       æŒ‡å®šç”Ÿæˆçš„ç±»å (é»˜è®¤: Assets)
  
  --short-naming               ä½¿ç”¨ç®€çŸ­å‘½å (çˆ¶çº§æ–‡ä»¶å¤¹+æ–‡ä»¶å) [é»˜è®¤]
  --full-naming                ä½¿ç”¨å®Œæ•´è·¯å¾„å‘½å
  
  --update-pubspec             è‡ªåŠ¨æ›´æ–° pubspec.yaml [é»˜è®¤]
  --no-update-pubspec          ä¸æ›´æ–° pubspec.yaml
  
  -i, --ignore <folders>       å¿½ç•¥æŒ‡å®šæ–‡ä»¶å¤¹ (ç”¨é€—å·åˆ†éš”)
  --clear-ignore               æ¸…ç©ºé»˜è®¤å¿½ç•¥åˆ—è¡¨

ç¤ºä¾‹:
  # ä½¿ç”¨é»˜è®¤é…ç½®
  flutter_chen_assets_generator
  
  # æŒ‡å®šèµ„æºç›®å½•å’Œè¾“å‡ºæ–‡ä»¶
  flutter_chen_assets_generator -a my_assets -o lib/assets.dart
  
  # ä½¿ç”¨å®Œæ•´å‘½åå¹¶å¿½ç•¥ç‰¹å®šæ–‡ä»¶å¤¹
  flutter_chen_assets_generator --full-naming -i web,fonts,temp
  
  # ç”ŸæˆæŒ‡å®šç±»åä¸”ä¸æ›´æ–°pubspec.yaml
  flutter_chen_assets_generator -c MyAssets --no-update-pubspec

é»˜è®¤å¿½ç•¥çš„æ–‡ä»¶å¤¹: ${FlutterAssetsGenerator.ignoredFolders.join(', ')}

æ›´å¤šä¿¡æ¯: https://pub.dev/packages/flutter_chen_assets_generator
''');
}

/// ä¸»å‡½æ•°
Future<void> main(List<String> arguments) async {
  print('ğŸš€ Flutter Chen Assets Generator v1.0.0');
  print('â•' * 50);

  // è§£æå‘½ä»¤è¡Œå‚æ•°
  if (_parseArguments(arguments)) {
    return;
  }

  try {
    await FlutterAssetsGenerator.generate();
    print('â•' * 50);
    print('ğŸ‰ ä»»åŠ¡å®Œæˆï¼');
  } catch (e, stackTrace) {
    print('âŒ ç”Ÿæˆå¤±è´¥: $e');
    print('å †æ ˆè·Ÿè¸ª: $stackTrace');
    exit(1);
  }
}
